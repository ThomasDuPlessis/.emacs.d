\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{enumitem}

\begin{document}

\centerline{AMS 545/CSE 555 (Spring, 2016) \hfill Joe Mitchell}
\medskip
\centerline{\Large\bf COMPUTATIONAL GEOMETRY}
\bigskip

\centerline{\Large\bf Homework Problem \# 11}

\bigskip


{\bf Upload your solution to Blackboard by the due date.}
You are expected to write up your solutions {\em on your own}, {\bf
without referring to other students' writeups or to solutions you may
find on the web}; you are welcome to discuss problems with me, the TA,
and classmates, but {\bf must do the writeup entirely on your own}.

\medskip
{\bf Do NOT write your name on your submission.} It is recorded with Blackboard, so we know who you are.  But we want your paper to be
anonymous, since it may be peer-assessed.
\medskip

\noindent Recommended Reading: BKOS: Chapter 2; O'Rourke sections 7.7, 7.8. Handout on Melkman's algorithm.



\medskip


\medskip
\noindent {\bf (11).} 
Problem 2.14, BCKO/BKOS.
Let $S$ be a set of $n$ disjoint line segments in a plane,
and let $p$ be a point not on any of the line segments of
$S$. We wish to determine all line segments of $S$ that
$p$ can see, that is, all line segments of $S$ that contain
some point $q$ so that the open segment $\overline{pq}$
doesn't intersect any line segment of $S$. Give an
$O(n \log n)$ time algorithm for this problem that uses a rotating
half-line with its endpoint at~$p$.

\textbf{ A: We will create a Sweeping half line algorithm to detect which line
  segments are visible to $p$. First we create events for the start and end of
  each line then sort them all by the angle between it and the horizontal line
  at $p$ in counterclockwise order. Then we can have a Sweeping Half Line status
  data structure implemented with a balanced binary tree that will hold the
  position of the lines on the current sweeping half line that is ordered on the
  position of each line on the sweeping half line, (which wont change since
  there are no intersections between lines, so the half line will only need to
  add and remove elements, not switch around orderings and BSTs) which can
  remain balanced without re-comparisons. So we go through each event, and if
  its the start of the line we add a new object to our sweeping line data
  structure, moving left or right down the BST based on whether or not it the
  starting point of the segment is to the left or right of the given line at
  each Node, and appending as a leaf when we can not go any farther down, then
  re-balancing the tree. If its the end of the line, we remove that line from
  the BST and rebalance. After each step, we check if the left most line in the
  BST has been marked seen, if not, we mark it and report it as seen. So since
  the the sorting is done in $O(nlog(n))$ and each BST operation takes at most
  $O(log(n))$ time, the overall run time of our algorithm is $O(nlog(n))$. The
  detailed algorithm is on the next page with an implementation of how we add to
  the Sweeping half line BST. }

\begin{algorithm}
\caption{Detect Lines Seen at P}
\begin{algorithmic}[]
  \Procedure{Detect-Containing-Points}{$S$, $p$}
    \State $EQ \gets []$
    \State $SHL \gets$  new empty BST()
    \For{$seg \in S$}
      \State Create Events $e1$ and $e2$ for both endpoints of $seg$      
      \State // Each event has the endpoint value, and a pointer to the $seg$
        \If{ $Left(p,e1,e2)$}
          \State label $e1$ as a STARTLINE event
          \State label $e2$ as an ENDLINE event
        \Else
          \State label $e2$ as a STARTLINE event
          \State label $e1$ as an ENDLINE event
        \EndIf
      \State Add events to $EQ$
    \EndFor
    \State Sort $EQ$ based on angle between the endpoint and the horizontal line at $p$ in CCW order
    \For{$e \in EQ$}
      \If{$e$ is labeled STARTLINE}
        \State $AddtoBST(SHL, e)$
        \State $seg \gets$ $getLeftMost$($SHL$)
        \State \textbf{Report} $seg$ as seeable
      \Else
        \State $SHL$.remove($e$)
      \EndIf
    \EndFor
  \EndProcedure
\\
  \Procedure{AddtoBST}{$BST$, $e$}
    \State $node \gets BST.root$
    \While{$true$}
      \If{$LeftOn(node.segment.start, node.segment.end, e)$}
        \If{$node.left$ == null}
          \State $node.left$ = $e$
          \State \textbf{BREAK}
        \Else
          \State $node$ = $node.left$
        \EndIf
      \Else 
        \If{$node.right$ == null}
          \State $node.right$ = $e$ 
          \State \textbf{BREAK}
        \Else
          \State $node$ = $node.left$
        \EndIf
      \EndIf
    \EndWhile
    \State $rebalance(SHL)$
  \EndProcedure
\end{algorithmic}
\end{algorithm}


\textbf{ A proof of correctness is the argument that if a line segment is seeable
  by $p$, it is seeable on the line segment between $p$ and some other end point
  of A segment because, if the whole segment is seeable, then of course its
  seeable on the line segment between $p$ and either of the lines endpoints, if
  the whole segment is not seeable, but some part is still seeable, then the
  line segment must become visible again at the line between $p$ and the
  endpoint of the line covering it. } \\

\textbf{ Note that this can have degeneracy's, first off, we don't specify
  from which starting point when sorting on angles in a clockwise order. The
  implementation given, assumes it starts at a line segment that is seen by $p$,
  which the one way to guarantee would be to start with the line with an
  endpoint closest to $p$. Anther degeneracy would arise if a point is not
  considered seen if the only line $pq$ intersects an endpoint of another
  segment,  which could lead to false positive if $p$ and two endpoints are colinear. }


\end{document}



